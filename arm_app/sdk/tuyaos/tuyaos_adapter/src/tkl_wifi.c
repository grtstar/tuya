/**
 * @file tkl_wifi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_wifi.h"
#include "tuya_error_code.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <pthread.h>
// --- END: user defines and implements ---

#define WLAN_DEV    "ens33"

STATIC WIFI_EVENT_CB wifi_status_cb;

STATIC VOID_T *wifi_status_event_cb(void *arg)
{
    WF_EVENT_E wf_event;
    WF_STATION_STAT_E stat = 0;
    WF_STATION_STAT_E last_stat = 0;
    int last_state = -1;

    pthread_detach (pthread_self());

    while (1) {
        tkl_wifi_station_get_status(&stat);
        if(stat != WSS_CONN_SUCCESS && stat != WSS_GOT_IP) {
            wf_event = WFE_DISCONNECTED;
        }
        if(stat == WSS_CONN_FAIL) {
            wf_event = WFE_CONNECT_FAILED;
        } else if(stat == WSS_GOT_IP || stat == WSS_CONN_SUCCESS) {
            wf_event = WFE_CONNECTED;
            if (last_stat != stat) {
                last_stat = stat;
                last_state = wf_event;
                wifi_status_cb(wf_event,NULL);
                sleep(1);
                continue;
            }
        }

        if(last_state == wf_event) {
            sleep(1);
            continue;
        }

        last_state = wf_event;
        wifi_status_cb(wf_event,NULL);
        sleep(1);
    }
}

/**
 * @brief set wifi station work status changed callback
 *
 * @param[in]      cb        the wifi station work status changed callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_init(WIFI_EVENT_CB cb)
{
    int iret = 0;
    pthread_t thread;
    wifi_status_cb = cb;

    iret = pthread_create(&thread,NULL,wifi_status_event_cb,NULL);
    if(iret) {
        printf("create status_cs thread failed");
        return -1;
    }

    return 0;
}

/**
 * @brief scan current environment and obtain the ap
 *        infos in current environment
 * 
 * @param[in]       ssid        the specific ssid
 * @param[out]      ap_ary      current ap info array
 * @param[out]      num         the num of ar_ary
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 * @note if ssid == NULL means scan all ap, otherwise means scan the specific ssid
 */
OPERATE_RET tkl_wifi_scan_ap(CONST SCHAR_T *ssid, AP_IF_S **ap_ary, UINT_T *num)
{
    //Developers implement the following AP scan functionality.
#if(0)
    OPERATE_RET ret = OPRT_OK;
    char* pary = NULL;
    uint32_t scan_cnt = 0;

    //ret = bsp_wifi_hal_all_ap_scan(&pary, &scan_cnt); // Developers platform Wi-Fi low-level interface.
    if (ret != OPRT_OK) {
        PR_ERR("wifi all ap scan err %d", ret);
        return OPRT_COM_ERROR;
    }

    if (scan_cnt <= 0 ) {
        PR_ERR("wifi all ap scan num is zero err");
        return OPRT_COM_ERROR;
    }
    ssid = NULL;
    *ap_ary = (AP_IF_S*) pary;
    *num = scan_cnt;
#endif
    return OPRT_OK;
}

/**
 * @brief release the memory malloced in <tkl_wifi_ap_scan>
 *        if needed. tuyaos will call this function when the 
 *        ap info is no use.
 * 
 * @param[in]       ap          the ap info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_release_ap(AP_IF_S *ap)
{//Static variables, no need to free
    return OPRT_OK;
}

/**
 * @brief start a soft ap
 * 
 * @param[in]       cfg         the soft ap config
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_start_ap(CONST WF_AP_CFG_IF_S *cfg)
{
    if(NULL == cfg){
        return OPRT_INVALID_PARM;
    }

    printf("Start AP SSID:%s \r\n", cfg->ssid);
    //Reserved
    return OPRT_OK;
}

/**
 * @brief stop a soft ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_stop_ap(VOID_T)
{
    printf("Stop AP \r\n");
    //Reserved
    return OPRT_OK;
}

static void exec_cmd(char *pCmd)
{
    printf("Exec Cmd:%s \r\n", pCmd);
    system(pCmd);
}

static int s_curr_channel = 1;
/**
 * @brief set wifi interface work channel
 * 
 * @param[in]       chan        the channel to set
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_cur_channel(CONST UCHAR_T chan)
{
    char tmpCmd[100] = {0};
    snprintf(tmpCmd, 100, "iwconfig %s channel %d", WLAN_DEV, chan);
    exec_cmd(tmpCmd);
    s_curr_channel = chan;

    printf("WIFI Set Channel:%d \r\n", chan);

    return OPRT_OK;
}

/**
 * @brief get wifi interface work channel
 * 
 * @param[out]      chan        the channel wifi works
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_cur_channel(UCHAR_T *chan)
{
    if(NULL == chan) {
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("iwlist "WLAN_DEV" channel", "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[128] = {0};
    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pIPStart = strstr(tmp, " (Channel ");
        if(pIPStart != NULL){
            break;
        }
    }

    /* find the channel	*/
    char *pCHANNELStart = strstr(tmp, " (Channel ");
    if(pCHANNELStart != NULL){
        int x = 0;
        sscanf(pCHANNELStart + strlen(" (Channel "), "%d", &x);
        *chan = x;
    }else{
        *chan = s_curr_channel;
    }

    pclose(pp);

    printf("WIFI Get Curr Channel:%d \r\n", *chan);

    return OPRT_OK;
}

OPERATE_RET tkl_wifi_set_sniffer(CONST BOOL_T en, CONST SNIFFER_CALLBACK cb)
{
    return OPRT_OK;
}

STATIC OPERATE_RET hwl_get_local_ip_info(char *interface,OUT NW_IP_S *ip)
{
    char tmp[256];

    memset(tmp, 0, sizeof(tmp));
    snprintf(tmp,sizeof(tmp),"ifconfig %s",interface);
    FILE *pp = popen(tmp, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pIPStart = strstr(tmp, "inet addr:");
        if(pIPStart != NULL){/* It's all a line containing IP GW mask that jumps out directly  */
            break;
        }
    }
    /* finding ip  */
    char *pIPStart = strstr(tmp, "inet addr:");
    if(pIPStart != NULL){
        sscanf(pIPStart + strlen("inet addr:"), "%15s", ip->ip);
    }
    /* finding gw  */
    char *pGWStart = strstr(tmp, "broadcast ");
    if(pGWStart != NULL){
        sscanf(pGWStart + strlen("broadcast "), "%s", ip->gw);
    }
    /* finding mask */
    char *pMASKStart = strstr(tmp, "netmask ");
    if(pMASKStart != NULL){
        sscanf(pMASKStart + strlen("netmask "), "%s", ip->mask);
    }

    pclose(pp);

    return OPRT_OK;
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 * 
 * @param[in]       wf          wifi function type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    if(NULL == ip){
        return OPRT_INVALID_PARM;
    }

    if(wf == WF_AP){/* Simple Processing in AP Mode */
        memcpy(ip->ip, "192.168.0.1", strlen("192.168.0.1"));
        memcpy(ip->gw, "192.168.0.1", strlen("192.168.0.1"));
        memcpy(ip->mask, "255.255.255.0", strlen("255.255.255.0"));
    }

    if(wf == WF_STATION){
        //get the ip of ethernet
        hwl_get_local_ip_info(WLAN_DEV,ip);

        NW_IP_S tmp;
        memset(&tmp,0,sizeof(NW_IP_S));
        //get the ip of wifi
        hwl_get_local_ip_info(WLAN_DEV,&tmp);
        if(strlen(tmp.ip)){
            //replace ip 
            memcpy(ip,&tmp,sizeof(NW_IP_S));
        }
    }

    printf("WIFI[%d] Get IP:%s\r\n", wf, ip->ip);
    return OPRT_OK;
}

/**
 * @brief set wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 * 
 * @param[in]       wf          wifi function type
 * @param[in]       mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_mac(CONST WF_IF_E wf, CONST NW_MAC_S *mac)
{
    if(NULL == mac){
        return OPRT_INVALID_PARM;
    }
    printf("WIFI Set MAC\r\n");
    //reserved
    return OPRT_OK;
}

/**
 * @brief get wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 * 
 * @param[in]       wf          wifi function type
 * @param[out]      mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_mac(CONST WF_IF_E wf, NW_MAC_S *mac)
{
    if(NULL == mac){
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("ifconfig "WLAN_DEV, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[256];
    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pMACStart = strstr(tmp, "ether ");
        if(pMACStart != NULL){
            int x1,x2,x3,x4,x5,x6;
            sscanf(pMACStart + strlen("ether "), "%x:%x:%x:%x:%x:%x",&x1,&x2,&x3,&x4,&x5,&x6);
            mac->mac[0] = x1 & 0xFF;
            mac->mac[1] = x2 & 0xFF;
            mac->mac[2] = x3 & 0xFF;
            mac->mac[3] = x4 & 0xFF;
            mac->mac[4] = x5 & 0xFF;
            mac->mac[5] = x6 & 0xFF;
            break;
        }
    }
    pclose(pp);
    printf("WIFI Get MAC %02X-%02X-%02X-%02X-%02X-%02X\r\n",
           mac->mac[0],mac->mac[1],mac->mac[2],mac->mac[3],mac->mac[4],mac->mac[5]);

    return OPRT_OK;
}

/**
 * @brief set wifi work mode
 * 
 * @param[in]       mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_work_mode(CONST WF_WK_MD_E mode)
{
    char tmpCmd[100] = {0};

    snprintf(tmpCmd, 100, "ifconfig %s up", WLAN_DEV);
    exec_cmd(tmpCmd);

    switch (mode)
    {
        case WWM_POWERDOWN:
        {
            //Linux system does not care about low power 
            break;
        }
        case WWM_SNIFFER:
        {
            snprintf(tmpCmd, 100, "iwconfig %s mode Monitor", WLAN_DEV);
            exec_cmd(tmpCmd);
            break;
        }
        case WWM_STATION:
        {
            snprintf(tmpCmd, 100, "iwconfig %s mode Managed", WLAN_DEV);
            exec_cmd(tmpCmd);
            break;
        }
        case WWM_SOFTAP:
        {
            snprintf(tmpCmd, 100, "iwconfig %s mode Master", WLAN_DEV);
            exec_cmd(tmpCmd);
            break;
        }
        case WWM_STATIONAP:
        {//reserved
            break;
        }
        default:
        {
            break;
        }
    }
    printf("WIFI Set Mode %d\r\n", mode);

    return OPRT_OK;
}

/**
 * @brief get wifi work mode
 * 
 * @param[out]      mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_work_mode(WF_WK_MD_E *mode)
{
    if(NULL == mode){
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("iwconfig "WLAN_DEV, "r");
    if(pp == NULL){
        printf("WIFI Get Mode Fail. Force Set Station \r\n");
        *mode = WWM_STATION;
        return OPRT_OK;
    }

    char scan_mode[10] = {0};
    char tmp[256] = {0};
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pModeStart = strstr(tmp, "Mode:");
        if(pModeStart != NULL){
            int x1,x2,x3,x4,x5,x6;
            sscanf(pModeStart + strlen("Mode:"), "%s ", scan_mode);
            break;
        }
    }
    pclose(pp);

    *mode = WWM_STATION;
    if(strncasecmp(scan_mode, "Managed", strlen("Managed")) == 0){
        *mode = WWM_STATION;
    }
    if(strncasecmp(scan_mode, "Master", strlen("Master")) == 0){
        *mode = WWM_SOFTAP;
    }
    if(strncasecmp(scan_mode, "Monitor", strlen("Monitor")) == 0){
        *mode = WWM_SNIFFER;
    }
//    printf("WIFI Get Mode [%s] %d\r\n", scan_mode, *mode);

    return OPRT_OK;
}

/**
 * @brief : get ap info for fast connect
 * @param[out]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_connected_ap_info(FAST_WF_CONNECTED_AP_INFO_T **fast_ap_info)
{
    return OPRT_OK;
}

/**
 * @brief get wifi bssid
 * 
 * @param[out]      mac         uplink mac
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_bssid(UCHAR_T *mac)
{
    return OPRT_OK;
}

/**
 * @brief set wifi country code
 * 
 * @param[in]       ccode  country code
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_country_code(CONST COUNTRY_CODE_E ccode)
{
    printf("Set Country Code:%d \r\n", ccode);

    return OPRT_OK;
}

/**
 * @brief do wifi calibration
 *
 * @note called when test wifi
 *
 * @return true on success. faile on failure
 */
OPERATE_RET tkl_wifi_set_rf_calibrated(VOID_T)
{
    return OPRT_OK;
}

/**
 * @brief set wifi lowpower mode
 * 
 * @param[in]       enable      enbale lowpower mode
 * @param[in]       dtim     the wifi dtim
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_lp_mode(CONST BOOL_T enable, CONST UCHAR_T dtim)
{
    return OPRT_OK;
}

/**
 * @brief : fast connect
 * @param[in]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_fast_connect(CONST FAST_WF_CONNECTED_AP_INFO_T *fast_ap_info)
{
    return OPRT_OK;
}

/**
 * @brief connect wifi with ssid and passwd
 * 
 * @param[in]       ssid
 * @param[in]       passwd
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_connect(CONST SCHAR_T *ssid, CONST SCHAR_T *passwd)
{
    //IPC_APP_Notify_LED_Sound_Status_CB(IPC_CONNECTING_WIFI);
    if(NULL == ssid){
        //get bind info from ethernet network
        printf("get bind info ...\n");
    }else{
        //get bind info from ap / wifi-smart / qrcode
        printf("get wifi info ...\n");
    }

    //TODO
    //Add a blocking operation for the wifi connection here.
    sleep(2);

    return OPRT_OK;
}

/**
 * @brief disconnect wifi from connect ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_disconnect(VOID_T)
{
    printf("STA Disconn AP\r\n");
    //Reserved

    return OPRT_OK;
}

/**
 * @brief get wifi connect rssi
 * 
 * @param[out]      rssi        the return rssi
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_conn_ap_rssi(SCHAR_T *rssi)
{
    if(NULL == rssi){
        return OPRT_INVALID_PARM;
    }
    *rssi = 0;

    FILE *pp = popen("iwconfig "WLAN_DEV, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[128] = {0};
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        /* find signal  */
        char *pSIGNALStart = strstr(tmp, "Quality=");
        if(pSIGNALStart != NULL)
        {
            int x = 0;
            int y = 0;
            sscanf(pSIGNALStart + strlen("Quality="), "%d/%d",&x,&y);
            *rssi = x * 100/ (y+1);
            break;
        }
    }
    pclose(pp);
    printf("Get Conn AP RSSI:%d\r\n", *rssi);

    return OPRT_OK;
}

/**
 * @brief get wifi station work status
 * 
 * @param[out]      stat        the wifi station work status
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_status(WF_STATION_STAT_E *stat)
{
    if(NULL == stat){
        return OPRT_INVALID_PARM;
    }
    *stat = WSS_GOT_IP; //Be sure to return in real time
    //Reserved
    return OPRT_OK;
}

/**
 * @brief send wifi management
 * 
 * @param[in]       buf         pointer to buffer
 * @param[in]       len         length of buffer
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_send_mgnt(CONST UCHAR_T *buf, CONST UINT_T len)
{
    return OPRT_OK;
}

/**
 * @brief register receive wifi management callback
 * 
 * @param[in]       enable
 * @param[in]       recv_cb     receive callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_register_recv_mgnt_callback(CONST BOOL_T enable, CONST WIFI_REV_MGNT_CB recv_cb)
{
    return OPRT_OK;
}

/**
 * @brief wifi ioctl
 *
 * @param[in]       cmd     refer to WF_IOCTL_CMD_E
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_ioctl(WF_IOCTL_CMD_E cmd,  VOID *args)
{
    return OPRT_OK;
}

