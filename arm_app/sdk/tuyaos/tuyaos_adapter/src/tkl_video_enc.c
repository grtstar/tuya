/**
 * @file tkl_video_enc.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include <stdio.h>
#include <sys/time.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include "tkl_video_enc.h"
#include "tkl_media_demo_source.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

extern int tkl_audio_file_read_cnt;
int tkl_video_file_read_cnt[2] = {0};

//#define TKL_VENC_MAIN_PATH     "apps/tuyaos_demo_ipc/resource/media/demo_video.264"
//#define TKL_VENC_SUB_PATH      "apps/tuyaos_demo_ipc/resource/media/demo_video.264"
#define TKL_VENC_MAIN_CODETYPE TKL_CODEC_VIDEO_H264
#define TKL_VENC_SUB_CODETYPE  TKL_CODEC_VIDEO_H264
#define TKL_VENC_MAIN_FPS      30
#define TKL_VENC_SUB_FPS       30

typedef struct {
    int codetype;
    unsigned long last_time;
    int seq;
    unsigned char *p_buf;
    unsigned int file_size;
    unsigned int start;
    int file_seq;
} TY_VENC_OBJ_T;

typedef struct {
    int init;
    TY_VENC_OBJ_T enc[2];
} TY_VENC_HANDLE_T;

static TY_VENC_HANDLE_T *ty_venc_get_handle()
{
    static TY_VENC_HANDLE_T s_venc_handle;
    return &s_venc_handle;
}

// 获取ms 时间
static unsigned long __get_time_ms()
{
    struct timeval tv;
    if (gettimeofday(&tv, NULL) < 0) {
        return 0;
    }
    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

/* This is for demo only. Should be replace with real H264 encoder output */
static int __read_one_frame_from_demo_video_file(unsigned char *pVideoBuf, unsigned int offset, unsigned int BufSize,
                                                 unsigned int *IskeyFrame, unsigned int *FramLen,
                                                 unsigned int *Frame_start)
{
    unsigned int pos = 0;
    int bNeedCal = 0;
    unsigned char NalType = 0;
    int idx = 0;
    if (BufSize <= 5) {
        printf("bufSize is too small\n");
        return -1;
    }
    for (pos = 0; pos <= BufSize - 5; pos++) {
        if (pVideoBuf[pos] == 0x00 && pVideoBuf[pos + 1] == 0x00 && pVideoBuf[pos + 2] == 0x00 &&
            pVideoBuf[pos + 3] == 0x01) {
            NalType = pVideoBuf[pos + 4] & 0x1f;
            if (NalType == 0x7) {
                if (bNeedCal == 1) {
                    *FramLen = pos - idx;
                    return 0;
                }

                *IskeyFrame = 1;
                *Frame_start = offset + pos;
                bNeedCal = 1;
                idx = pos;
            } else if (NalType == 0x1) {
                if (bNeedCal) {
                    *FramLen = pos - idx;
                    return 0;
                }
                *Frame_start = offset + pos;
                *IskeyFrame = 0;
                idx = pos;
                bNeedCal = 1;
            }
        }
    }

    *FramLen = BufSize;

    return 0;
}

static int __read_one_frame_from_demo_video_file_hevc(unsigned char *pVideoBuf, unsigned int offset,
                                                      unsigned int BufSize, unsigned int *IskeyFrame,
                                                      unsigned int *FramLen, unsigned int *Frame_start)
{
    unsigned int pos = 0;
    int bNeedCal = 0;
    unsigned char NalType = 0;
    int idx = 0;
    if (BufSize <= 5) {
        printf("bufSize is too small\n");
        return -1;
    }
    for (pos = 0; pos <= BufSize - 5; pos++) {
        if (pVideoBuf[pos] == 0x00 && pVideoBuf[pos + 1] == 0x00 && pVideoBuf[pos + 2] == 0x00 &&
            pVideoBuf[pos + 3] == 0x01) {
            NalType = (pVideoBuf[pos + 4] & 0x7E) >> 1;
            if (NalType == 0x20) {
                if (bNeedCal == 1) {
                    *FramLen = pos - idx;
                    return 0;
                }

                *IskeyFrame = 1;
                *Frame_start = offset + pos;
                bNeedCal = 1;
                idx = pos;
            } else if (NalType == 0x1) {
                if (bNeedCal) {
                    *FramLen = pos - idx;
                    return 0;
                }
                *Frame_start = offset + pos;
                *IskeyFrame = 0;
                idx = pos;
                bNeedCal = 1;
            }
        }
    }

    *FramLen = BufSize;
    return 0;
}

/**
 * @brief video encode init
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] pconfig: venc config
 * @param[in] count: count of pconfig
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_init(INT32_T vi_chn, TKL_VENC_CONFIG_T *pconfig, INT32_T count)
{
    (void)vi_chn;
    (void)pconfig;
    (void)count;
    int i = 0;
    TY_VENC_HANDLE_T *p_hand = ty_venc_get_handle();
    if (p_hand->init == 1) {
        printf("tkl_venc_init is always initialized\n");
        return OPRT_OK;
    }


    for (i = 0; i < 2; i++) {
        p_hand->enc[i].p_buf = s_DEMO_VIDEO_H264;
        p_hand->enc[i].file_size = sizeof(s_DEMO_VIDEO_H264);

        p_hand->enc[i].last_time = __get_time_ms();
        p_hand->enc[i].seq = 0;
        p_hand->enc[i].start = 0;
        p_hand->enc[i].file_seq = 0;
    }

    p_hand->enc[0].codetype = TKL_VENC_MAIN_CODETYPE;
    p_hand->enc[1].codetype = TKL_VENC_SUB_CODETYPE;

    p_hand->init = 1;
    printf("tkl_venc_init end\n");
    return OPRT_OK;
}

static int __get_enc_frame(TKL_VENC_CHN_E venc_chn, TKL_VENC_FRAME_T *pframe)
{
    TY_VENC_HANDLE_T *p_hand = ty_venc_get_handle();
    TY_VENC_OBJ_T *p_enc = &p_hand->enc[venc_chn];
    unsigned char *p_buf = p_enc->p_buf;
    unsigned int frame_start = 0;
    unsigned int key_frame = 0;
    unsigned int offset = 0;
    unsigned int frame_len = 0;
    long time_tmp = 0;
    unsigned int sleep_time = 0;

    offset = p_enc->start;
    if (offset >= p_enc->file_size) {
        printf("rewind video %d file, %d %d\n", venc_chn, offset, p_enc->file_size);
        offset = 0;
        p_enc->start = 0;
        tkl_video_file_read_cnt[venc_chn]++;
    }

    // 视频文件比音频文件短，视频文件播放到尾部时，等待音频文件播放完成
    if (tkl_video_file_read_cnt[venc_chn] > tkl_audio_file_read_cnt) {
        //printf("venc_chn, tkl_video_file_read_cnt[venc_chn], tkl_audio_file_read_cnt:%d %d %d\n", venc_chn, tkl_video_file_read_cnt[venc_chn], tkl_audio_file_read_cnt);
        usleep(40*1000);
        return -1;
    }

    if (p_enc->codetype == TKL_CODEC_VIDEO_H265) {
        __read_one_frame_from_demo_video_file_hevc(p_buf + offset, offset, p_enc->file_size - offset, &key_frame,
                                                   &frame_len, &frame_start);

    } else {
        __read_one_frame_from_demo_video_file(p_buf + offset, offset, p_enc->file_size - offset, &key_frame, &frame_len,
                                              &frame_start);
    }

    if (frame_len > pframe->buf_size) {
        printf("frame buf_size[%d] is not enough, need %d\n", pframe->buf_size, frame_len);
        return OPRT_COM_ERROR;
    }
    // Note: For I frame of H264, SPS/PPS/SEI/IDR should be combined within one frame, and the NALU separator should NOT
    // be deleted.
    if (key_frame == 1) {
        pframe->frametype = TKL_VIDEO_I_FRAME;
    } else {
        pframe->frametype = TKL_VIDEO_PB_FRAME;
    }

    if (venc_chn == 1){
        sleep_time = 1000 *1000 / TKL_VENC_SUB_FPS;
    } else {
        sleep_time = 1000 *1000 / TKL_VENC_MAIN_FPS;
    }

    // frame->height = 640;
    // frame->width = 360;
    pframe->pts = __get_time_ms();
    pframe->timestamp = __get_time_ms();
    pframe->used_size = frame_len;
    pframe->seq = p_enc->seq++;
    pframe->codectype = p_enc->codetype;
    memcpy(pframe->pbuf, p_buf + frame_start, frame_len);

    p_enc->start = frame_start + frame_len;

    if (offset == 0){
        printf("rewind video start %d\n", venc_chn);
        p_enc->file_seq = 0;
        p_enc->last_time = __get_time_ms();
    }

    // 前2帧不sleep，直接发送
    if (p_enc->file_seq > 2) {
        time_tmp = (__get_time_ms() - p_enc->last_time) * 1000 - (sleep_time * (p_enc->file_seq -3));
        if (time_tmp < sleep_time) { 
            usleep(sleep_time - time_tmp);
        }
    }
    p_enc->file_seq++;

    return 0;
}

// read jpeg
static int __get_enc_jpeg(TKL_VENC_FRAME_T *pframe)
{
    unsigned char *p_buf = s_DEMO_VIDEO_JPEG;
    unsigned int frame_len = sizeof(s_DEMO_VIDEO_JPEG);

    if (frame_len > pframe->buf_size) {
        printf("frame buf_size[%d] is not enough, need %d\n", pframe->buf_size, frame_len);
        return OPRT_COM_ERROR;
    }

    pframe->frametype = TKL_VIDEO_PB_FRAME;
    pframe->pts = __get_time_ms();
    pframe->timestamp = __get_time_ms();
    pframe->used_size = frame_len;
    pframe->codectype = TKL_CODEC_VIDEO_MJPEG;
    memcpy(pframe->pbuf, p_buf, frame_len);

    return 0;
}

/**
 * @brief video encode get frame
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 * @param[out] pframe:  output frame
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_get_frame(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn, TKL_VENC_FRAME_T *pframe)
{
    (void)vi_chn;

    TY_VENC_HANDLE_T *p_hand = ty_venc_get_handle();
    if (p_hand->init != 1) {
        return OPRT_COM_ERROR;
    }

    if (venc_chn == 0 || venc_chn == 1) {
        return __get_enc_frame(venc_chn, pframe);
    } else if (venc_chn == 4) {
        return __get_enc_jpeg(pframe);
    } else {
        printf("venc:%d, not support\n", venc_chn);
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
}

/**
 * @brief video first snap
 *
 * @param[in] vi_chn: vi channel number
 * @param[out] pframe: output frame
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_get_first_snap(TKL_VI_CHN_E vi_chn, TKL_VENC_FRAME_T *pframe)
{
    (void)vi_chn;
    (void)pframe;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode set osd
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 * @param[out] posd:  osd config
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_set_osd(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn, TKL_VENC_OSD_T *posd)
{
    (void)vi_chn;
    (void)venc_chn;
    (void)posd;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode stream buff pool set
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 * @param[in] parg:  buff pool config
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_set_video_stream_buffer(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn, TKL_VENC_STREAM_BUFF_T *parg)
{
    (void)vi_chn;
    (void)venc_chn;
    (void)parg;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode  start
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_start(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn)
{
    (void)vi_chn;
    (void)venc_chn;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode  stop
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_stop(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn)
{
    (void)vi_chn;
    (void)venc_chn;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode set osd
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 * @param[in] idr_type: request idr type
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_set_IDR(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn, TKL_VENC_IDR_E idr_type)
{
    (void)vi_chn;
    (void)venc_chn;
    (void)idr_type;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode set mask
 *
 * @param[in] vi_chn: vi channel number
 * @param[in] venc_chn: venc channel number
 * @param[out] pmask: mask config
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_set_mask(TKL_VI_CHN_E vi_chn, TKL_VENC_CHN_E venc_chn, TKL_VENC_MASK_T *pmask)
{
    (void)vi_chn;
    (void)venc_chn;
    (void)pmask;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief video encode uninit
 *
 * @param[in] vi_chn: vi channel number
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_venc_uninit(TKL_VI_CHN_E vi_chn)
{
    (void)vi_chn;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}
