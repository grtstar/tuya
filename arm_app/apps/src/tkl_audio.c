/**
 * @file tkl_audio.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include <stdio.h>
#include <sys/time.h>
#include <unistd.h>
#include "tkl_audio.h"
#include "tkl_media_demo_source.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

#define TKL_AUDIO_FRAME_SIZE 640

int tkl_audio_file_read_cnt = 0;
typedef struct {
    int ai_init;
    unsigned long ai_time;
    int seq;
} TY_AUDIO_HANDLE_T;

static TY_AUDIO_HANDLE_T *ty_audio_get_handle()
{
    static TY_AUDIO_HANDLE_T s_audio_handle;
    return &s_audio_handle;
}

static unsigned long __get_time_ms()
{
    struct timeval tv;
    if (gettimeofday(&tv, NULL) < 0) {
        return 0;
    }
    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
}

/**
 * @brief ai init
 *
 * @param[in] pconfig: audio config
 * @param[in] count: count of pconfig
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_init(TKL_AUDIO_CONFIG_T *pconfig, INT32_T count)
{
    (void)pconfig;
    (void)count;

    TY_AUDIO_HANDLE_T *p_hand = ty_audio_get_handle();
    if (p_hand->ai_init == 1) {
        printf("tkl_ai_init is always initialized\n");
        return OPRT_OK;
    }
    p_hand->ai_init = 1;
    p_hand->seq = 0;
    p_hand->ai_time = __get_time_ms();
    printf("tkl_ai_init\n");
    return OPRT_OK;
}

/**
 * @brief ai start
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_start(INT32_T card, TKL_AI_CHN_E chn)
{
    (void)card;
    (void)chn;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ai set mic volume
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[in] vol: mic volume,[0, 100]
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_set_vol(INT32_T card, TKL_AI_CHN_E chn, INT32_T vol)
{
    (void)card;
    (void)chn;
    (void)vol;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ai get frame
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[out] pframe: audio frame, pframe->pbuf allocated by upper layer application
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_get_frame(INT32_T card, TKL_AI_CHN_E chn, TKL_AUDIO_FRAME_INFO_T *pframe)
{
    (void)card;
    TY_AUDIO_HANDLE_T *p_hand = ty_audio_get_handle();
    long time_tmp = 0;
    static int s_send_size = 0;

    if (p_hand->ai_init != 1) {
        printf("tkl_ai_init isnot initialized or fp is NULL\n");
        return OPRT_COM_ERROR;
    }

    if (chn != TKL_AI_0) {
        printf("type = %d is not support now !!!\n", chn);
        return OPRT_COM_ERROR;
    }

    if (s_send_size + TKL_AUDIO_FRAME_SIZE > sizeof(s_DEMO_AUDIO_PCM)){
        printf("rewind audio file, %d %ld\n", s_send_size, sizeof(s_DEMO_AUDIO_PCM));
        s_send_size = 0;
        tkl_audio_file_read_cnt ++;
    }

    memcpy(pframe->pbuf,&s_DEMO_AUDIO_PCM[s_send_size], TKL_AUDIO_FRAME_SIZE);
    pframe->codectype = TKL_CODEC_AUDIO_PCM;
    pframe->used_size = TKL_AUDIO_FRAME_SIZE;
    pframe->timestamp = __get_time_ms();
    pframe->pts = __get_time_ms();
    pframe->type = TKL_AUDIO_FRAME;
    pframe->seq = p_hand->seq++;
    pframe->sample = 8000;

    s_send_size += TKL_AUDIO_FRAME_SIZE;

    // 前2帧不sleep，直接发送
    if (p_hand->seq > 2) {
        time_tmp = __get_time_ms() - p_hand->ai_time - (40 * (p_hand->seq -3));
        //printf("time_tmp:%ld\n", time_tmp);
        if (time_tmp < 40 && time_tmp >= 0) {
            usleep((40 - time_tmp) * 1000);
        }
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ai stop
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_stop(INT32_T card, TKL_AI_CHN_E chn)
{
    (void)card;
    (void)chn;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ai uninit
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_uninit(VOID)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ao init
 *
 * @param[in] pconfig: audio config
 * @param[in] count: config count
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_init(TKL_AUDIO_CONFIG_T *pconfig, INT32_T count, VOID **handle)
{
    (void)pconfig;
    (void)count;
    (void)handle;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ao start
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[out] handle: handle of start
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_start(INT32_T card, TKL_AO_CHN_E chn, VOID *handle)
{
    (void)card;
    (void)chn;
    (void)handle;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ao set volume
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[in] vol: mic volume,[0, 100]
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_set_vol(INT32_T card, TKL_AO_CHN_E chn, VOID *handle, INT32_T vol)
{
    (void)card;
    (void)chn;
    (void)handle;
    (void)vol;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ao get volume
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[in] vol: mic volume,[0, 100]
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_get_vol(INT32_T card, TKL_AO_CHN_E chn, VOID *handle, INT32_T *vol)
{
    (void)card;
    (void)chn;
    (void)handle;
    (void)vol;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief ao output frame
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[in] handle: handle of start
 * @param[in] pframe: output frame
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_put_frame(INT32_T card, TKL_AO_CHN_E chn, VOID *handle, TKL_AUDIO_FRAME_INFO_T *pframe)
{
    (void)card;
    (void)chn;
    (void)handle;
    (void)pframe;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief ao stop
 *
 * @param[in] card: card number
 * @param[in] chn: channel number
 * @param[in] handle: handle of start
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_stop(INT32_T card, TKL_AO_CHN_E chn, VOID *handle)
{
    (void)card;
    (void)chn;
    (void)handle;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief ao uninit
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ao_uninit(VOID *handle)
{
    (void)handle;
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief audio input detect start
 *
 * @param[in] card: card number
 * @param[in] type: detect type
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_detect_start(INT32_T card, TKL_MEDIA_DETECT_TYPE_E type)
{
    (void)card;
    (void)type;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief audio input detect stop
 *
 * @param[in] card: card number
 * @param[in] type: detect type
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_detect_stop(INT32_T card, TKL_MEDIA_DETECT_TYPE_E type)
{
    (void)card;
    (void)type;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief audio detect get result
 *
 * @param[in] card: card number
 * @param[in] type: detect type
 * @param[out] presult: audio detect result
 *
 * @return OPRT_OK on success. Others on error, please refer to tkl_error_code.h
 */
OPERATE_RET tkl_ai_detect_get_result(INT32_T card, TKL_MEDIA_DETECT_TYPE_E type, TKL_AUDIO_DETECT_RESULT_T *presult)
{
    (void)card;
    (void)type;
    (void)presult;
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}
