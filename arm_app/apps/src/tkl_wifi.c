/**
 * @file tkl_wifi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 * 
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 * 
 */

// --- BEGIN: user defines and implements ---
#include "tkl_wifi.h"
#include "tuya_error_code.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <pthread.h>

#ifdef RK_DEVICEIO
#include <DeviceIo/Rk_wifi.h>
#endif
#include "tuya.h"
#include "voice.h"
#include "wifi/wifimg.h"
#include "wifi/wmg_common.h"
#include "wifi/wmg_sta.h"
// --- END: user defines and implements ---

#define WLAN_DEV    "wlan0"


#ifdef RK_DEVICEIO
int _RK_wifi_state_callback(RK_WIFI_RUNNING_State_e state)
{
printf("_RK_wifi_state_callback state:%d\n", state);
return 0;
}

#else
void wifi_msg_cb(wifi_msg_data_t *msg)
{
    switch (msg->id)
    {
    case WIFI_MSG_ID_DEV_STATUS:
        switch (msg->data.d_status)
        {
        case WLAN_STATUS_DOWN:
            LOGD("***** wifi msg cb: dev status down *****\n");
            break;
        case WLAN_STATUS_UP:
            LOGD("***** wifi msg cb: dev status up *****\n");
            break;
        default:
            LOGD("***** wifi msg cb: dev status unknow *****\n");
            break;
        }
        //			status = ROBOT_WIFI_NOT_CONNECT;
        break;
    case WIFI_MSG_ID_STA_CN_EVENT:
        switch (msg->data.event)
        {
        case WIFI_DISCONNECTED:
            //					status = ROBOT_WIFI_NOT_CONNECT;
            LOGD("***** wifi msg cb: sta event disconnect *****\n");
            break;
        case WIFI_SCAN_STARTED:
            LOGD("***** wifi msg cb: sta event scan started *****\n");
            break;
        case WIFI_SCAN_FAILED:
            LOGD("***** wifi msg cb: sta event scan failed *****\n");
            break;
        case WIFI_SCAN_RESULTS:
            LOGD("***** wifi msg cb: sta event scan results *****\n");
            break;
        case WIFI_NETWORK_NOT_FOUND:
            //					status = ROBOT_WIFI_NOT_CONNECT;
            PlayVoice(V_WIFI_NOTFOUND, 0);
            LOGD("***** wifi msg cb: sta event network not found *****\n");
            break;
        case WIFI_PASSWORD_INCORRECT:
            PlayVoice(V_WIFI_FAIL, 0);
            //					status = ROBOT_WIFI_NOT_CONNECT;
            LOGD("***** wifi msg cb: sta event password incorrect *****\n");
            break;
        case WIFI_AUTHENTIACATION:
            LOGD("***** wifi msg cb: sta event authentiacation *****\n");
            break;
        case WIFI_AUTH_REJECT:
            //					status = ROBOT_WIFI_NOT_CONNECT;
            LOGD("***** wifi msg cb: sta event auth reject *****\n");
            break;
        case WIFI_ASSOCIATING:
            LOGD("***** wifi msg cb: sta event associating *****\n");
            break;
        case WIFI_ASSOC_REJECT:
            //					status = ROBOT_WIFI_NOT_CONNECT;
            LOGD("***** wifi msg cb: sta event assoc reject *****\n");
            break;
        case WIFI_ASSOCIATED:
            LOGD("***** wifi msg cb: sta event associated *****\n");
            break;
        case WIFI_4WAY_HANDSHAKE:
            LOGD("***** wifi msg cb: sta event 4 way handshake *****\n");
            break;
        case WIFI_GROUNP_HANDSHAKE:
            LOGD("***** wifi msg cb: sta event grounp handshake *****\n");
            break;
        case WIFI_GROUNP_HANDSHAKE_DONE:
            LOGD("***** wifi msg cb: sta event handshake done *****\n");
            break;
        case WIFI_CONNECTED:
            //					status = ROBOT_WIFI_CONNECTED;
            LOGD("***** wifi msg cb: sta event connected *****\n");
            break;
        case WIFI_CONNECT_TIMEOUT:
            LOGD("***** wifi msg cb: sta event connect timeout *****\n");
            break;
        case WIFI_DEAUTH:
            LOGD("***** wifi msg cb: sta event deauth *****\n");
            break;
        case WIFI_DHCP_START:
            LOGD("***** wifi msg cb: sta event dhcp start *****\n");
            break;
        case WIFI_DHCP_TIMEOUT:
            LOGD("***** wifi msg cb: sta event dhcp timeout *****\n");
            break;
        case WIFI_DHCP_SUCCESS:
            //					status = ROBOT_WIFI_CONNECTED;
            LOGD("***** wifi msg cb: sta event dhcp success *****\n");
            break;
        case WIFI_TERMINATING:
            LOGD("***** wifi msg cb: sta event terminating *****\n");
            break;
        case WIFI_UNKNOWN:
            //					status = ROBOT_WIFI_ERROR;
        default:
            LOGD("***** wifi msg cb: sta event unknow *****\n");
            break;
        }
        break;
    case WIFI_MSG_ID_STA_STATE_CHANGE:
        switch (msg->data.state)
        {
        case WIFI_STA_IDLE:
            LOGD("***** wifi msg cb: sta state idle *****\n");
            break;
        case WIFI_STA_CONNECTING:
            LOGD("***** wifi msg cb: sta state connecting *****\n");
            break;
        case WIFI_STA_CONNECTED:
            LOGD("***** wifi msg cb: sta state connected *****\n");
            break;
        case WIFI_STA_OBTAINING_IP:
            LOGD("***** wifi msg cb: sta state obtaining ip *****\n");
            break;
        case WIFI_STA_NET_CONNECTED:
            LOGD("***** wifi msg cb: sta state net connected *****\n");
            break;
        case WIFI_STA_DHCP_TIMEOUT:
            LOGD("***** wifi msg cb: sta state dhcp timeout *****\n");
            break;
        case WIFI_STA_DISCONNECTING:
            LOGD("***** wifi msg cb: sta state disconnecting *****\n");
            break;
        case WIFI_STA_DISCONNECTED:
            LOGD("***** wifi msg cb: sta state disconnected *****\n");
            break;
        default:
            LOGD("***** wifi msg cb: sta state unknow *****\n");
            break;
        }
        break;
    case WIFI_MSG_ID_AP_CN_EVENT:
        switch (msg->data.ap_event)
        {
        case WIFI_AP_ENABLED:
            LOGD("***** wifi msg cb: ap enable *****\n");
            break;
        case WIFI_AP_DISABLED:
            LOGD("***** wifi msg cb: ap disable *****\n");
            break;
        case WIFI_AP_STA_DISCONNECTED:
            LOGD("***** wifi msg cb: ap sta disconnected *****\n");
            break;
        case WIFI_AP_STA_CONNECTED:
            LOGD("***** wifi msg cb: ap sta connected *****\n");
            break;
        case WIFI_AP_UNKNOWN:
        default:
            LOGD("***** wifi msg cb: ap event unknow *****\n");
            break;
        }
        break;
    case WIFI_MSG_ID_MONITOR:
        switch (msg->data.mon_state)
        {
        case WIFI_MONITOR_DISABLE:
            LOGD("***** wifi msg cb: monitor disable *****\n");
            break;
        case WIFI_MONITOR_ENABLE:
            LOGD("***** wifi msg cb: monitor enable *****\n");
            break;
        default:
            LOGD("***** wifi msg cb: monitor state unknow *****\n");
            break;
        }
        break;
    default:
        break;
    }
}
#endif

STATIC WIFI_EVENT_CB wifi_status_cb;

STATIC VOID_T *wifi_status_event_cb(void *arg)
{
    WF_EVENT_E wf_event;
    WF_STATION_STAT_E stat = 0;
    WF_STATION_STAT_E last_stat = 0;
    int last_state = -1;

    pthread_detach (pthread_self());

    while (1) {
        tkl_wifi_station_get_status(&stat);
        if(stat != WSS_CONN_SUCCESS && stat != WSS_GOT_IP) {
            wf_event = WFE_DISCONNECTED;
        }
        if(stat == WSS_CONN_FAIL) {
            wf_event = WFE_CONNECT_FAILED;
        } else if(stat == WSS_GOT_IP || stat == WSS_CONN_SUCCESS) {
            wf_event = WFE_CONNECTED;
            if (last_stat != stat) {
                last_stat = stat;
                last_state = wf_event;
                wifi_status_cb(wf_event,NULL);
                sleep(1);
                continue;
            }
        }

        if(last_state == wf_event) {
            sleep(1);
            continue;
        }

        last_state = wf_event;
        wifi_status_cb(wf_event,NULL);
        sleep(1);
    }
}

/**
 * @brief set wifi station work status changed callback
 *
 * @param[in]      cb        the wifi station work status changed callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_init(WIFI_EVENT_CB cb)
{
    int iret = 0;
    pthread_t thread;
    wifi_status_cb = cb;

    iret = pthread_create(&thread,NULL,wifi_status_event_cb,NULL);
    if(iret) {
        printf("create status_cs thread failed");
        return -1;
    }

#ifdef RK_DEVICEIO
    RK_wifi_ble_register_callback(_RK_wifi_state_callback);
#else
    wifimanager_init();
    if (!get_wifimg_object()->is_init() && get_wifimg_object()->init())
    {
        LOGE("wifimg init fail\n");
        return WMG_STATUS_NOT_READY;
    }
    if (wifi_register_msg_cb(wifi_msg_cb))
    {
        LOGE("wifi register msg cb fail\n");
        return WMG_STATUS_FAIL;
    }
#endif
    printf("wifi init success\n");
    return WMG_STATUS_SUCCESS;

    return 0;
}

/**
 * @brief scan current environment and obtain the ap
 *        infos in current environment
 * 
 * @param[in]       ssid        the specific ssid
 * @param[out]      ap_ary      current ap info array
 * @param[out]      num         the num of ar_ary
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 * @note if ssid == NULL means scan all ap, otherwise means scan the specific ssid
 */
OPERATE_RET tkl_wifi_scan_ap(CONST SCHAR_T *ssid, AP_IF_S **ap_ary, UINT_T *num)
{
    //Developers implement the following AP scan functionality.
#if(0)
    OPERATE_RET ret = OPRT_OK;
    char* pary = NULL;
    uint32_t scan_cnt = 0;

    //ret = bsp_wifi_hal_all_ap_scan(&pary, &scan_cnt); // Developers platform Wi-Fi low-level interface.
    if (ret != OPRT_OK) {
        PR_ERR("wifi all ap scan err %d", ret);
        return OPRT_COM_ERROR;
    }

    if (scan_cnt <= 0 ) {
        PR_ERR("wifi all ap scan num is zero err");
        return OPRT_COM_ERROR;
    }
    ssid = NULL;
    *ap_ary = (AP_IF_S*) pary;
    *num = scan_cnt;
#endif
    return OPRT_OK;
}

/**
 * @brief release the memory malloced in <tkl_wifi_ap_scan>
 *        if needed. tuyaos will call this function when the 
 *        ap info is no use.
 * 
 * @param[in]       ap          the ap info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_release_ap(AP_IF_S *ap)
{//Static variables, no need to free
    return OPRT_OK;
}

/**
 * @brief start a soft ap
 * 
 * @param[in]       cfg         the soft ap config
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_start_ap(CONST WF_AP_CFG_IF_S *cfg)
{
    if(NULL == cfg){
        return OPRT_INVALID_PARM;
    }

    printf("Start AP SSID:%s, ip: %s\r\n", cfg->ssid, cfg->ip.ip);
     char ssid[128] = {0};
    strncpy(ssid, cfg->ssid, sizeof(ssid));
    char passwd[128] = {0};
    strncpy(passwd, cfg->passwd, sizeof(passwd));
    wifi_ap_config_t ap_config = {0};
    ap_config.ssid = ssid;
    ap_config.psk = passwd;
    ap_config.channel = cfg->chan;
    ap_config.sec = cfg->md;
    //ap_config.ip = cfg->ip.ip;
    int r = wifi_ap_enable(&ap_config);
    if(WMG_STATUS_SUCCESS != r)
    {
        printf("wifi_ap_enable failed: %d\n", r);
        return OPRT_COM_ERROR;
    }
    printf("Start AP Success\n");
    return OPRT_OK;
}

/**
 * @brief stop a soft ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_stop_ap(VOID_T)
{
    printf("Stop AP \r\n");
    //Reserved
    int r = wifi_ap_disable();
    if(r != WMG_STATUS_SUCCESS)
    {
        printf("wifi_ap_disable failed: %d\n", r);
        return OPRT_COM_ERROR;
    }
    return OPRT_OK;
}

static void exec_cmd(char *pCmd)
{
    printf("Exec Cmd:%s \r\n", pCmd);
    system(pCmd);
}

static int s_curr_channel = 1;
/**
 * @brief set wifi interface work channel
 * 
 * @param[in]       chan        the channel to set
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_cur_channel(CONST UCHAR_T chan)
{
    char tmpCmd[100] = {0};
    snprintf(tmpCmd, 100, "iwconfig %s channel %d", WLAN_DEV, chan);
    exec_cmd(tmpCmd);
    s_curr_channel = chan;

    printf("WIFI Set Channel:%d \r\n", chan);

    return OPRT_OK;
}

/**
 * @brief get wifi interface work channel
 * 
 * @param[out]      chan        the channel wifi works
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_cur_channel(UCHAR_T *chan)
{
    if(NULL == chan) {
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("iwlist "WLAN_DEV" channel", "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[128] = {0};
    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pIPStart = strstr(tmp, " (Channel ");
        if(pIPStart != NULL){
            break;
        }
    }

    /* find the channel	*/
    char *pCHANNELStart = strstr(tmp, " (Channel ");
    if(pCHANNELStart != NULL){
        int x = 0;
        sscanf(pCHANNELStart + strlen(" (Channel "), "%d", &x);
        *chan = x;
    }else{
        *chan = s_curr_channel;
    }

    pclose(pp);

    printf("WIFI Get Curr Channel:%d \r\n", *chan);

    return OPRT_OK;
}

OPERATE_RET tkl_wifi_set_sniffer(CONST BOOL_T en, CONST SNIFFER_CALLBACK cb)
{
    return OPRT_OK;
}

STATIC OPERATE_RET hwl_get_local_ip_info(char *interface,OUT NW_IP_S *ip)
{
    char tmp[256];

    memset(tmp, 0, sizeof(tmp));
    snprintf(tmp,sizeof(tmp),"ifconfig %s",interface);
    FILE *pp = popen(tmp, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pIPStart = strstr(tmp, "inet addr:");
        if(pIPStart != NULL){/* It's all a line containing IP GW mask that jumps out directly  */
            break;
        }
    }
    /* finding ip  */
    char *pIPStart = strstr(tmp, "inet addr:");
    if(pIPStart != NULL){
        sscanf(pIPStart + strlen("inet addr:"), "%15s", ip->ip);
    }
    else
    {
        pclose(pp);
        return OPRT_COM_ERROR;
    }
    /* finding gw  */
    char *pGWStart = strstr(tmp, "broadcast ");
    if(pGWStart != NULL){
        sscanf(pGWStart + strlen("broadcast "), "%s", ip->gw);
    }
    /* finding mask */
    char *pMASKStart = strstr(tmp, "netmask ");
    if(pMASKStart != NULL){
        sscanf(pMASKStart + strlen("netmask "), "%s", ip->mask);
    }

    pclose(pp);

    return OPRT_OK;
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 * 
 * @param[in]       wf          wifi function type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    if(NULL == ip){
        return OPRT_INVALID_PARM;
    }

    if(wf == WF_AP){/* Simple Processing in AP Mode */
        hwl_get_local_ip_info(WLAN_DEV,ip);
        // memcpy(ip->ip, "192.168.176.1", strlen("192.168.176.1"));
        // memcpy(ip->gw, "192.168.176.1", strlen("192.168.176.1"));
        // memcpy(ip->mask, "255.255.255.0", strlen("255.255.255.0"));
    }

    if(wf == WF_STATION){
        //get the ip of ethernet
        hwl_get_local_ip_info(WLAN_DEV,ip);

        NW_IP_S tmp;
        memset(&tmp,0,sizeof(NW_IP_S));
        //get the ip of wifi
        hwl_get_local_ip_info(WLAN_DEV,&tmp);
        if(strlen(tmp.ip)){
            //replace ip 
            memcpy(ip,&tmp,sizeof(NW_IP_S));
        }
    }

    printf("WIFI[%d] Get IP:%s\r\n", wf, ip->ip);
    return OPRT_OK;
}

/**
 * @brief set wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 * 
 * @param[in]       wf          wifi function type
 * @param[in]       mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_mac(CONST WF_IF_E wf, CONST NW_MAC_S *mac)
{
    if(NULL == mac){
        return OPRT_INVALID_PARM;
    }
    printf("WIFI Set MAC\r\n");
    //reserved
    return OPRT_OK;
}

/**
 * @brief get wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 * 
 * @param[in]       wf          wifi function type
 * @param[out]      mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_mac(CONST WF_IF_E wf, NW_MAC_S *mac)
{
    if(NULL == mac){
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("ifconfig "WLAN_DEV, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[256];
    memset(tmp, 0, sizeof(tmp));
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pMACStart = strstr(tmp, "HWaddr ");
        if(pMACStart != NULL){
            int x1,x2,x3,x4,x5,x6;
            sscanf(pMACStart + strlen("HWaddr "), "%x:%x:%x:%x:%x:%x",&x1,&x2,&x3,&x4,&x5,&x6);
            mac->mac[0] = x1 & 0xFF;
            mac->mac[1] = x2 & 0xFF;
            mac->mac[2] = x3 & 0xFF;
            mac->mac[3] = x4 & 0xFF;
            mac->mac[4] = x5 & 0xFF;
            mac->mac[5] = x6 & 0xFF;
            break;
        }
    }
    pclose(pp);
    printf("WIFI Get MAC %02X-%02X-%02X-%02X-%02X-%02X\r\n",
           mac->mac[0],mac->mac[1],mac->mac[2],mac->mac[3],mac->mac[4],mac->mac[5]);

    return OPRT_OK;
}

/**
 * @brief set wifi work mode
 * 
 * @param[in]       mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_work_mode(CONST WF_WK_MD_E mode)
{
    char tmpCmd[100] = {0};

    snprintf(tmpCmd, 100, "ifconfig %s up", WLAN_DEV);
    exec_cmd(tmpCmd);

    switch (mode)
    {
        case WWM_POWERDOWN:
        {
            //Linux system does not care about low power 
            break;
        }
        case WWM_SNIFFER:
        {
            // snprintf(tmpCmd, 100, "iwconfig %s mode Monitor", WLAN_DEV);
            // exec_cmd(tmpCmd);
            wifi_on(WIFI_MONITOR);
            break;
        }
        case WWM_STATION:
        {
            // snprintf(tmpCmd, 100, "iwconfig %s mode Managed", WLAN_DEV);
            // exec_cmd(tmpCmd);
            wifi_on(WIFI_STATION);
            break;
        }
        case WWM_SOFTAP:
        {
            // snprintf(tmpCmd, 100, "iwconfig %s mode Master", WLAN_DEV);
            // exec_cmd(tmpCmd);
            wifi_on(WIFI_AP);
            break;
        }
        case WWM_STATIONAP:
        {//reserved
            break;
        }
        default:
        {
            break;
        }
    }
    printf("WIFI Set Mode %d\r\n", mode);

    return OPRT_OK;
}

/**
 * @brief get wifi work mode
 * 
 * @param[out]      mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_work_mode(WF_WK_MD_E *mode)
{
    if(NULL == mode){
        return OPRT_INVALID_PARM;
    }

    FILE *pp = popen("iwconfig "WLAN_DEV, "r");
    if(pp == NULL){
        printf("WIFI Get Mode Fail. Force Set Station \r\n");
        *mode = WWM_STATION;
        return OPRT_OK;
    }

    char scan_mode[10] = {0};
    char tmp[256] = {0};
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        char *pModeStart = strstr(tmp, "Mode:");
        if(pModeStart != NULL){
            int x1,x2,x3,x4,x5,x6;
            sscanf(pModeStart + strlen("Mode:"), "%s ", scan_mode);
            break;
        }
    }
    pclose(pp);

    *mode = WWM_STATION;
    if(strncasecmp(scan_mode, "Managed", strlen("Managed")) == 0){
        *mode = WWM_STATION;
    }
    if(strncasecmp(scan_mode, "Master", strlen("Master")) == 0){
        *mode = WWM_SOFTAP;
    }
    if(strncasecmp(scan_mode, "Monitor", strlen("Monitor")) == 0){
        *mode = WWM_SNIFFER;
    }
//    printf("WIFI Get Mode [%s] %d\r\n", scan_mode, *mode);

    return OPRT_OK;
}

/**
 * @brief : get ap info for fast connect
 * @param[out]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_connected_ap_info(FAST_WF_CONNECTED_AP_INFO_T **fast_ap_info)
{
    return OPRT_OK;
}

/**
 * @brief get wifi bssid
 * 
 * @param[out]      mac         uplink mac
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_bssid(UCHAR_T *mac)
{
    wifi_sta_info_t sta_info = {0};
    if(WMG_STATUS_SUCCESS == wifi_sta_get_info(&sta_info))
    {
        memcpy(mac, sta_info.bssid, sizeof(sta_info.bssid));
    }
    return OPRT_OK;
}

/**
 * @brief set wifi country code
 * 
 * @param[in]       ccode  country code
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_country_code(CONST COUNTRY_CODE_E ccode)
{
    printf("Set Country Code:%d \r\n", ccode);

    return OPRT_OK;
}

/**
 * @brief do wifi calibration
 *
 * @note called when test wifi
 *
 * @return true on success. faile on failure
 */
OPERATE_RET tkl_wifi_set_rf_calibrated(VOID_T)
{
    return OPRT_OK;
}

/**
 * @brief set wifi lowpower mode
 * 
 * @param[in]       enable      enbale lowpower mode
 * @param[in]       dtim     the wifi dtim
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_lp_mode(CONST BOOL_T enable, CONST UCHAR_T dtim)
{
    return OPRT_OK;
}

/**
 * @brief : fast connect
 * @param[in]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_fast_connect(CONST FAST_WF_CONNECTED_AP_INFO_T *fast_ap_info)
{
    return OPRT_OK;
}

/**
 * @brief connect wifi with ssid and passwd
 * 
 * @param[in]       ssid
 * @param[in]       passwd
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_connect(CONST SCHAR_T *ssid, CONST SCHAR_T *passwd)
{
    //IPC_APP_Notify_LED_Sound_Status_CB(IPC_CONNECTING_WIFI);
    if(NULL == ssid){
        //get bind info from ethernet network
        printf("get bind info ...\n");
    }else{
        //get bind info from ap / wifi-smart / qrcode
        printf("get wifi info ... %s(%d) %s\n", ssid, strlen(ssid), passwd);
    }
    if(ssid[0] == 0)
    {
        printf("no ssid info\n");
        return OPRT_COM_ERROR;
    }

    //TODO
    //Add a blocking operation for the wifi connection here.
#ifdef RK_DEVICEIO
    RK_wifi_enable(1);
    RK_wifi_connect(ssid, passwd);
#else

    wifi_sta_info_t sta_info = {0};
    int rr = wifi_sta_get_info(&sta_info);
    printf("wifi_sta_get_info: %d\n", rr);
    wifi_on(WIFI_STATION);
    wifi_sta_cn_para_t sta = {0};
    sta.ssid = ssid;
    sta.password = passwd;
    if(passwd == NULL || strlen(passwd) == 0)
    {
        sta.sec = WIFI_SEC_NONE;
    }
    else
    {
        sta.sec = WIFI_SEC_WPA2_PSK;
    }
    int r = wifi_sta_connect(&sta);
    if(WMG_STATUS_SUCCESS != r)
    {
        printf("wifi_sta_connect failed: %d\n", r);
        return OPRT_COM_ERROR;
    }
#endif
    printf("STA Connect AP\r\n");
    PlayVoice(V_WIFI_RECV_PWD, PLAY_QUEUE);

    return OPRT_OK;
}

/**
 * @brief disconnect wifi from connect ap
 * 
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_disconnect(VOID_T)
{
    printf("STA Disconn AP\r\n");
    //Reserved
#ifdef RK_DEVICEIO
    RK_wifi_disconnect_network();
#else
    int r = wifi_sta_disconnect();
    if(WMG_STATUS_SUCCESS != r)
    {
        printf("wifi_sta_disconnect failed: %d\n", r);
        return OPRT_COM_ERROR;
    }
#endif
    return OPRT_OK;
}

/**
 * @brief get wifi connect rssi
 * 
 * @param[out]      rssi        the return rssi
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_conn_ap_rssi(SCHAR_T *rssi)
{
    if(NULL == rssi){
        return OPRT_INVALID_PARM;
    }
    *rssi = 0;

    FILE *pp = popen("iwconfig "WLAN_DEV, "r");
    if(pp == NULL){
       return OPRT_COM_ERROR;
    }

    char tmp[128] = {0};
    while (fgets(tmp, sizeof(tmp), pp) != NULL){
        /* find signal  */
        char *pSIGNALStart = strstr(tmp, "Quality=");
        if(pSIGNALStart != NULL)
        {
            int x = 0;
            int y = 0;
            sscanf(pSIGNALStart + strlen("Quality="), "%d/%d",&x,&y);
            *rssi = x * 100/ (y+1);
            break;
        }
    }
    pclose(pp);
    printf("Get Conn AP RSSI:%d\r\n", *rssi);

    return OPRT_OK;
}

/**
 * @brief get wifi station work status
 * 
 * @param[out]      stat        the wifi station work status
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_status(WF_STATION_STAT_E *stat)
{
    if(NULL == stat){
        return OPRT_INVALID_PARM;
    }
   NW_IP_S ip;
#ifdef RK_DEVICEIO
    static bool first = true;
    if (first)
    {
        if (RK_wifi_running_getState(&runningStatus))
        {
            return OPRT_COM_ERROR;
        }
        RK_wifi_register_callback(_RK_wifi_state_callback);
        first = false;
    }

    switch (runningStatus)
    {
    case RK_WIFI_State_IDLE:
        *stat = WSS_IDLE;
        break;
    case RK_WIFI_State_CONNECTING:
        *stat = WSS_CONNECTING;
        break;
    case RK_WIFI_State_CONNECTFAILED:
        *stat = WSS_CONN_FAIL;
        break;
    case RK_WIFI_State_CONNECTFAILED_WRONG_KEY:
        *stat = WSS_PASSWD_WRONG;
        break;
    case RK_WIFI_State_CONNECTED:
    {
        if (hwl_get_local_ip_info("wlan0", &ip) == OPRT_OK)
        {
            *stat = WSS_GOT_IP;
        }
        else
        {
            *stat = WSS_CONN_SUCCESS;
        }
    }

    break;
    case RK_WIFI_State_DISCONNECTED:
        *stat = WSS_CONN_FAIL;
        break;
    case RK_WIFI_State_OPEN:
        *stat = WSS_IDLE;
        break;
    case RK_WIFI_State_OFF:
        *stat = WSS_IDLE;
        break;
    default:
        break;
    }

    printf("======> tuya_adapter_wifi_station_get_status %d\n", *stat);
#else
    WF_WK_MD_E mode;
    tkl_wifi_get_work_mode(&mode);
    if(mode == WWM_SOFTAP)
    {
        *stat = WSS_IDLE;
    }
    else
    {
        if (hwl_get_local_ip_info("wlan0", &ip) == OPRT_OK && strlen(ip.ip) > 0)
        {
            printf("ip:%s\n", ip.ip);
            *stat = WSS_GOT_IP; // Be sure to return in real time
        }
        else
        {
            *stat = WSS_IDLE;
        }
    }
   
#endif
    printf("Current WiFi Station Status: %d\n", *stat);
    return OPRT_OK;
}

OPERATE_RET tkl_wifi_get_ssid(char *ssid)
{
#ifdef RK_DEVICEIO
    RK_WIFI_INFO_Connection_s info;
    RK_wifi_running_getConnectionInfo(&info);

    strncpy(ssid, info.ssid, sizeof(info.ssid));
#else
    wifi_sta_info_t sta_info = {0};
    if(WMG_STATUS_SUCCESS == wifi_sta_get_info(&sta_info))
    {
        if(sta_info.ssid[0] == '\\' && sta_info.ssid[1] == 'x')
        {
            int i = 0;
            int j = 0;
            for(i = 0; i < strlen(sta_info.ssid); i += 4)
            {
                char tmp[3] = {sta_info.ssid[i+2], sta_info.ssid[i + 3], '\0'};
                ssid[j++] = strtol(tmp, NULL, 16);
            }
            ssid[j] = '\0';
        }
        else
        {
            strncpy(ssid, sta_info.ssid, sizeof(sta_info.ssid));
        }
    }
#endif
    return 0;
}


/**
 * @brief send wifi management
 * 
 * @param[in]       buf         pointer to buffer
 * @param[in]       len         length of buffer
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_send_mgnt(CONST UCHAR_T *buf, CONST UINT_T len)
{
    return OPRT_OK;
}

/**
 * @brief register receive wifi management callback
 * 
 * @param[in]       enable
 * @param[in]       recv_cb     receive callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_register_recv_mgnt_callback(CONST BOOL_T enable, CONST WIFI_REV_MGNT_CB recv_cb)
{
    return OPRT_OK;
}

/**
 * @brief wifi ioctl
 *
 * @param[in]       cmd     refer to WF_IOCTL_CMD_E
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_ioctl(WF_IOCTL_CMD_E cmd,  VOID *args)
{
    return OPRT_OK;
}

